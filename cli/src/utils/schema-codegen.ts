import { jsonSchemaToZod } from "json-schema-to-zod";
import type { ExtractionResult } from "./schema-extractor.js";

/** Schema entry with its generated Zod code and naming info */
interface SchemaEntry {
  serviceName: string;
  actionName: string;
  exportName: string;
  typeName: string;
  zodCode: string;
}

/**
 * Convert a service.action name pair into a camelCase export name.
 * Example: ("tasks", "create") -> "tasksCreateSchema"
 */
const toSchemaExportName = (service: string, action: string): string => {
  const pascalAction = action.charAt(0).toUpperCase() + action.slice(1);
  return `${toCamelCase(service)}${pascalAction}Schema`;
};

/**
 * Convert a service.action name pair into a PascalCase type name.
 * Example: ("tasks", "create") -> "TasksCreatePayload"
 */
const toTypeExportName = (service: string, action: string): string => {
  const pascalService =
    toCamelCase(service).charAt(0).toUpperCase() +
    toCamelCase(service).slice(1);
  const pascalAction = action.charAt(0).toUpperCase() + action.slice(1);
  return `${pascalService}${pascalAction}Payload`;
};

/** Convert kebab-case to camelCase */
const toCamelCase = (str: string): string =>
  str.replace(/-([a-z])/g, (_, char: string) => char.toUpperCase());

/** Generate the file header with timestamp */
const generateHeader = (): string => {
  const timestamp = new Date().toISOString();
  return [
    `// Auto-generated by @nilejs/cli on ${timestamp}`,
    "// Do not edit manually. Re-run `nile generate schema` to update.",
    "",
  ].join("\n");
};

/**
 * Convert all extracted JSON Schemas into SchemaEntry objects with Zod code.
 * Uses json-schema-to-zod for the JSON Schema -> Zod code conversion.
 */
const buildSchemaEntries = (extraction: ExtractionResult): SchemaEntry[] => {
  const entries: SchemaEntry[] = [];

  for (const [serviceName, actions] of Object.entries(extraction.schemas)) {
    for (const [actionName, jsonSchema] of Object.entries(actions)) {
      const zodCode = jsonSchemaToZod(jsonSchema as Record<string, unknown>, {
        noImport: true,
      });

      entries.push({
        serviceName,
        actionName,
        exportName: toSchemaExportName(serviceName, actionName),
        typeName: toTypeExportName(serviceName, actionName),
        zodCode,
      });
    }
  }

  return entries;
};

/**
 * Generate the schemas.ts file content.
 * Contains named Zod schema exports for every action with validation.
 */
export const generateSchemasFile = (extraction: ExtractionResult): string => {
  const entries = buildSchemaEntries(extraction);

  if (entries.length === 0) {
    return `${generateHeader()}\n// No action schemas found.\n`;
  }

  const lines: string[] = [generateHeader(), `import { z } from "zod";`, ""];

  for (const entry of entries) {
    lines.push(`export const ${entry.exportName} = ${entry.zodCode};`);
    lines.push("");
  }

  if (extraction.skipped.length > 0) {
    lines.push(`// Skipped (no validation): ${extraction.skipped.join(", ")}`);
    lines.push("");
  }

  return lines.join("\n");
};

/**
 * Generate the types.ts file content.
 * Contains TypeScript type exports inferred from the Zod schemas.
 */
export const generateTypesFile = (extraction: ExtractionResult): string => {
  const entries = buildSchemaEntries(extraction);

  if (entries.length === 0) {
    return `${generateHeader()}\n// No action types found.\n`;
  }

  const schemaImports = entries.map((e) => e.exportName);
  const lines: string[] = [
    generateHeader(),
    `import type { z } from "zod";`,
    "import type {",
    ...schemaImports.map((name, i) =>
      i < schemaImports.length - 1 ? `  ${name},` : `  ${name},`
    ),
    `} from "./schemas";`,
    "",
  ];

  for (const entry of entries) {
    lines.push(
      `export type ${entry.typeName} = z.infer<typeof ${entry.exportName}>;`
    );
  }

  lines.push("");

  return lines.join("\n");
};
